// Generated by CoffeeScript 1.7.1
var Category, Entry, Schema, categorySchema, entrySchema, mongoose;

mongoose = require("mongoose");

Schema = mongoose.Schema;

entrySchema = new Schema({
  title: {
    type: String,
    index: {
      unique: true
    }
  },
  author: String,
  url: String,
  body: String,
  tags: [
    {
      name: String
    }
  ],
  category: String,
  comments: [
    {
      body: String,
      date: Date
    }
  ],
  creationDate: {
    type: Date,
    "default": Date.now
  },
  updateDate: {
    type: Date,
    "default": Date.now
  },
  published: Boolean
}, {
  collection: "entries"
});

Entry = mongoose.model("Entry", entrySchema);

categorySchema = new Schema({
  name: String
}, {
  collection: "categories"
});

Category = mongoose.model("Category", categorySchema);

module.exports = {
  getEntries: function(limit, skip, callback) {
    return Entry.find({}, null, {
      skip: skip,
      limit: limit
    }).sort({
      creationDate: "desc"
    }).exec(function(err, result) {
      if (!err) {
        err = null;
      }
      return callback(err, result);
    });
  },
  countEntries: function(callback) {
    return Entry.count({}, function(err, count) {
      return callback(err, count);
    });
  },
  countPages: function(limit, callback) {
    return Entry.count({}, function(err, count) {
      return callback(err, Math.ceil(count / limit));
    });
  },
  getEntry: function(param, callback) {
    return Entry.find(param, function(err, data) {
      if (!err) {
        err = null;
      }
      return callback(err, data);
    });
  },
  createEntry: function(entry, callback) {
    var newEntry;
    newEntry = new Entry(entry);
    return newEntry.save(function(err, newEntry, numberAffected) {
      if (!err) {
        err = null;
      }
      return callback(err, newEntry);
    });
  },
  removeEntry: function(id, callback) {
    return Entry.remove({
      _id: id
    }, function(err, data) {
      if (!err) {
        err = null;
      }
      return callback(err, data);
    }).remove();
  },
  editEntry: function(id, modifiedEntry, callback) {
    if (modifiedEntry.hasOwnProperty("_id")) {
      delete modifiedEntry._id;
    }
    return Entry.findOneAndUpdate({
      _id: id
    }, modifiedEntry, {
      "new": true
    }, function(err, data) {
      if (!err) {
        err = null;
      }
      return callback(err, data);
    });
  },
  getTags: function(callback) {
    return Entry.find({}, function(err, data) {
      var array, i, j, map;
      array = new Array();
      map = {};
      i = void 0;
      j = void 0;
      for (i in data) {
        array = array.concat(data[i].tags);
      }
      for (i in array) {
        if (array[i].name in map) {
          map[array[i].name] += 1;
        } else {
          map[array[i].name] = 1;
        }
      }
      return callback(err, map);
    });
  },
  getCategories: function(callback) {
    return Category.find({}, function(err, result) {
      if (!err) {
        err = null;
      }
      return callback(err, result);
    });
  },
  getCategory: function(id, callback) {
    return Category.find({
      _id: id
    }, function(err, data) {
      if (!err) {
        err = null;
      }
      return callback(err, data);
    });
  },
  createCategory: function(category, callback) {
    var newCategory;
    newCategory = new Category(category);
    return newCategory.save(function(err, newCategory, numberAffected) {
      if (!err) {
        err = null;
      }
      return callback(err, newCategory);
    });
  },
  removeCategory: function(id, callback) {
    return Category.remove({
      _id: id
    }, function(err, data) {
      if (!err) {
        err = null;
      }
      return callback(err, data);
    }).remove();
  },
  editCategory: function(id, modifiedCategory, callback) {
    if (modifiedCategory.hasOwnProperty("_id")) {
      delete modifiedCategory._id;
    }
    return Category.findOneAndUpdate({
      _id: id
    }, modifiedCategory, {
      "new": true
    }, function(err, data) {
      if (!err) {
        err = null;
      }
      return callback(err, data);
    });
  }
};
